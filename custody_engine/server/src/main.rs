
// Import tonic (gRPC framework) and the generated Rust service types
use tonic::transport::Server;
pub mod service;
use service::key_service::MyKeyService;
use service::signing_service::MySigningService;
use service::signing_service::SigningSessionStore;
use service::health_service::MyHealthService;
use service::vc_service::CustodyVcService;
use service::custody_management_service::CustodyManagementServer;
use service::relay_service::RelayService;
use custodyrelay::custody_relay_server::CustodyRelayServer;
use custody_engine::logging::init_logging;
use custody::custody_management_service_server::CustodyManagementServiceServer;
use custody::custody_vc_server::CustodyVcServer;
use crate::server::custody_management_service::CustodyManagementServer;
//use custody::key_service_server::KeyServiceServer;
//use custody::signing_service_server::SigningServiceServer;
//use custody::health_service_server::HealthServiceServer;

// Load the generated Rust code from custody.proto (auto-generated by tonic_build)
pub mod custody {
    tonic::include_proto!("custody");
}

pub mod custody_registry {
    tonic::include_proto!("custody_registry");
}

pub mod custodyrelay {
    tonic::include_proto!("custodyrelay");
}

// Start the gRPC server using the Tokio async runtime
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Set up logging (e.g., info!, error!, etc.)
    tracing_subscriber::fmt::init();
    init_logging("/var/log/custody", true); // JSON preferred in prod

    // Output simple startup message to the console (visible to user)
    info!("Starting Custody gRPC Server on [::1}:50051");

    // Create a shared store for signing sessions
    let signing_store = SigningSessionStore::default();
    let signing_service = MySigningService {
        store: Arc::new(signing_store),
    };

    // Create a shared OperationalDIDRegistry
    let did_registry = OperationalDIDRegistry::new();

    // Initialize custody management service
    let custody_mgmt_service = CustodyManagementServer {
        registry: did_registry.clone(),
    };

    let vc_service = CustodyVcService {
        issuer_registry: IssuerRegistry::new();
    };

    let relay_service = RelayService {
        dkg_engine: Arc::new(dkg_engine_instance),
        local_node_id: config.local_node_id.clone(),
    };

    // Start the gRPC server and bind our service handlers (to be implemented)
    server::builder()
        .add_service(KeyServiceServer::new(MyKeyService::default()))
        .add_service(SigningServiceServer::new(MySigningService::default()))
        .add_service(HealthServiceServer::new(MyHealthService::default()))
        .add_service(CustodyManagementServiceServer::new(custody_mgmt_service))
        .add_service(CustodyRelayServer::new(relay_service))
        .add_service(CustodyVcServer::new(vc_service))
        .serve("[::1]:50051".parse()?)
        .await?;
    Ok(())
}

// Use TLS/mTLS â†’ add .tls_config(...) to the server builder
// We can skip TLS for local dev but should include it for production.
// to run the gRPC server
// cargo run -p custody_server

// then check health endpoint useing grpcurl
// grpcurl -plaintext localhost:50051 custody.HealthService/Check